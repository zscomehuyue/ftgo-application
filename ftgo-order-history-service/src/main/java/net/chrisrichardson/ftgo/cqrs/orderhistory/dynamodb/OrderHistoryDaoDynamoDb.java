package net.chrisrichardson.ftgo.cqrs.orderhistory.dynamodb;


import com.amazonaws.services.dynamodbv2.document.DynamoDB;
import com.amazonaws.services.dynamodbv2.document.Index;
import com.amazonaws.services.dynamodbv2.document.Item;
import com.amazonaws.services.dynamodbv2.document.ItemCollection;
import com.amazonaws.services.dynamodbv2.document.PrimaryKey;
import com.amazonaws.services.dynamodbv2.document.QueryOutcome;
import com.amazonaws.services.dynamodbv2.document.RangeKeyCondition;
import com.amazonaws.services.dynamodbv2.document.Table;
import com.amazonaws.services.dynamodbv2.document.spec.GetItemSpec;
import com.amazonaws.services.dynamodbv2.document.spec.QuerySpec;
import com.amazonaws.services.dynamodbv2.document.spec.UpdateItemSpec;
import com.amazonaws.services.dynamodbv2.model.AttributeValue;
import com.amazonaws.services.dynamodbv2.model.ConditionalCheckFailedException;
import com.amazonaws.services.dynamodbv2.model.ReturnValue;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import net.chrisrichardson.ftgo.common.Money;
import net.chrisrichardson.ftgo.cqrs.orderhistory.Location;
import net.chrisrichardson.ftgo.cqrs.orderhistory.OrderHistory;
import net.chrisrichardson.ftgo.cqrs.orderhistory.OrderHistoryDao;
import net.chrisrichardson.ftgo.cqrs.orderhistory.OrderHistoryFilter;
import net.chrisrichardson.ftgo.orderservice.api.events.OrderLineItem;
import net.chrisrichardson.ftgo.orderservice.api.events.OrderState;
import org.apache.commons.lang.StringUtils;
import org.joda.time.DateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.math.BigDecimal;
import java.text.BreakIterator;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.StreamSupport;

import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;

public class OrderHistoryDaoDynamoDb implements OrderHistoryDao {

    private Logger logger = LoggerFactory.getLogger(getClass());

    public static final String FTGO_ORDER_HISTORY_BY_ID = "ftgo-order-history";
    public static final String FTGO_ORDER_HISTORY_BY_CONSUMER_ID_AND_DATE =
            "ftgo-order-history-by-consumer-id-and-creation-time";
    public static final String ORDER_STATUS_FIELD = "orderStatus";
    private static final String DELIVERY_STATUS_FIELD = "deliveryStatus";

    private final DynamoDB dynamoDB;

    private Table table;
    private Index index;

    public OrderHistoryDaoDynamoDb(DynamoDB dynamoDB) {
        this.dynamoDB = dynamoDB;
        table = this.dynamoDB.getTable(FTGO_ORDER_HISTORY_BY_ID);
        index = table.getIndex(FTGO_ORDER_HISTORY_BY_CONSUMER_ID_AND_DATE);
    }

    @Override
    public boolean addOrder(Order order, Optional<SourceEvent> eventSource) {
        UpdateItemSpec spec = new UpdateItemSpec()
                .withPrimaryKey("orderId", order.getOrderId())
                .withUpdateExpression("SET orderStatus = :orderStatus, " +
                        "creationDate = :creationDate, consumerId = :consumerId, lineItems =" +
                        " :lineItems, keywords = :keywords, restaurantId = :restaurantId, " +
                        " restaurantName = :restaurantName"
                )
                .withValueMap(new Maps()
                        .add(":orderStatus", order.getStatus().toString())
                        .add(":consumerId", order.getConsumerId())
                        .add(":creationDate", order.getCreationDate().getMillis())
                        .add(":lineItems", mapLineItems(order.getLineItems()))
                        .add(":keywords", mapKeywords(order))
                        .add(":restaurantId", order.getRestaurantId())
                        .add(":restaurantName", order.getRestaurantName())
                        .map())
                .withReturnValues(ReturnValue.NONE);
        return idempotentUpdate(spec, eventSource);
    }

    private boolean idempotentUpdate(UpdateItemSpec spec, Optional<SourceEvent>
            eventSource) {
        try {
            table.updateItem(eventSource.map(es -> es.addDuplicateDetection(spec))
                    .orElse(spec));
            return true;
        } catch (ConditionalCheckFailedException e) {
            logger.error("not updated {}", eventSource);
            // Do nothing
            return false;
        }
    }

////  @Override
//  public void addOrderV1(Order order, Optional<SourceEvent> eventSource) {
//    Map<String, AttributeValue> keyMapBuilder = makeKey1(order.getOrderId());
//    AvMapBuilder expressionAttrs = new AvMapBuilder(":orderStatus", new
// AttributeValue(order.getStatus().toString()))
//            .add(":cd", new AttributeValue().withN(Long.toString(order
// .getCreationDate().getMillis())))
//            .add(":consumerId", order.getConsumerId())
//            .add(":lineItems", mapLineItems(order.getLineItems()))
//            .add(":keywords", mapKeywords(order))
//            .add(":restaurantName", order.getRestaurantId())
//            ;
//
//
//    UpdateItemRequest uir = new UpdateItemRequest()
//            .withTableName(FTGO_ORDER_HISTORY_BY_ID)
//            .withKey(keyMapBuilder)
//            .withUpdateExpression("SET orderStatus = :orderStatus,
// creationDate = :cd, consumerId = :consumerId, lineItems = :lineItems,
// keywords = :keywords, restaurantName = :restaurantName")
//            .withConditionExpression("attribute_not_exists(orderStatus)")
//            .withExpressionAttributeValues(expressionAttrs.map());
//    try {
//      client.updateItem(uir);
//    } catch (ConditionalCheckFailedException e) {
//      // Do nothing
//    }
//  }

    private Set mapKeywords(Order order) {
        Set<String> keywords = new HashSet<>();
        keywords.addAll(tokenize(order.getRestaurantName()));
        keywords.addAll(tokenize(order.getLineItems().stream().map
                (OrderLineItem::getName).collect(toList())));
        return keywords;
    }

    private Set<String> tokenize(Collection<String> text) {
        return text.stream().flatMap(t -> tokenize(t).stream()).collect(toSet());
    }

    private Set<String> tokenize(String text) {
        Set<String> result = new HashSet<>();
        BreakIterator bi = BreakIterator.getWordInstance();
        bi.setText(text);
        int lastIndex = bi.first();
        while (lastIndex != BreakIterator.DONE) {
            int firstIndex = lastIndex;
            lastIndex = bi.next();
            if (lastIndex != BreakIterator.DONE
                    && Character.isLetterOrDigit(text.charAt(firstIndex))) {
                String word = text.substring(firstIndex, lastIndex);
                result.add(word);
            }
        }
        return result;
    }

    private List mapLineItems(List<OrderLineItem> lineItems) {
        return lineItems.stream().map(this::mapOrderLineItem).collect(toList());
    }
//  private AttributeValue mapLineItems(List<OrderLineItem> lineItems) {
//    AttributeValue result = new AttributeValue();
//    result.withL(lineItems.stream().map(this::mapOrderLineItem).collect
// (toList()));
//    return result;
//  }

    private Map mapOrderLineItem(OrderLineItem orderLineItem) {
        return new Maps()
                .add("menuItemName", orderLineItem.getName())
                .add("menuItemId", orderLineItem.getMenuItemId())
                .add("price", orderLineItem.getPrice().asString())
                .add("quantity", orderLineItem.getQuantity())
                .map();
    }
//  private AttributeValue mapOrderLineItem(OrderLineItem orderLineItem) {
//    AttributeValue result = new AttributeValue();
//    result.addMEntry("menuItem", new AttributeValue(orderLineItem
// .getName()));
//    return result;
//  }


    private Map<String, AttributeValue> makeKey1(String orderId) {
        return new AvMapBuilder("orderId", new AttributeValue(orderId)).map();
    }

    @Override
    public OrderHistory findOrderHistory(String consumerId, OrderHistoryFilter
            filter) {

        QuerySpec spec = new QuerySpec()
                .withScanIndexForward(false)
                .withHashKey("consumerId", consumerId)
                .withRangeKeyCondition(new RangeKeyCondition("creationDate").gt
                        (filter.getSince().getMillis()));

        filter.getStartKeyToken().ifPresent(token -> spec.withExclusiveStartKey
                (toStartingPrimaryKey(token)));

        Map<String, Object> valuesMap = new HashMap<>();

        String filterExpression = Expressions.and(
                keywordFilterExpression(valuesMap, filter.getKeywords()),
                statusFilterExpression(valuesMap, filter.getStatus()));

        if (!valuesMap.isEmpty())
            spec.withValueMap(valuesMap);

        if (StringUtils.isNotBlank(filterExpression)) {
            spec.withFilterExpression(filterExpression);
        }

        System.out.print("filterExpression.toString()=" + filterExpression);

        filter.getPageSize().ifPresent(spec::withMaxResultSize);

        ItemCollection<QueryOutcome> result = index.query(spec);

        return new OrderHistory(StreamSupport.stream(result.spliterator(), false)
                .map(this::toOrder).collect(toList()),
                Optional.ofNullable(result.getLastLowLevelResult().getQueryResult
                        ().getLastEvaluatedKey()).map(this::toStartKeyToken));
    }

    private PrimaryKey toStartingPrimaryKey(String token) {
        ObjectMapper om = new ObjectMapper();
        Map<String, Object> map;
        try {
            map = om.readValue(token, Map.class);
        } catch (IOException e) {
            throw new RuntimeException();
        }
        PrimaryKey pk = new PrimaryKey();
        map.entrySet().forEach(key -> {
            pk.addComponent(key.getKey(), key.getValue());
        });
        return pk;
    }

    private String toStartKeyToken(Map<String, AttributeValue> lastEvaluatedKey) {
        Map<String, Object> map = new HashMap<>();
        lastEvaluatedKey.entrySet().forEach(entry -> {
            String value = entry.getValue().getS();
            if (value == null) {
                value = entry.getValue().getN();
                map.put(entry.getKey(), Long.parseLong(value));
            } else {
                map.put(entry.getKey(), value);
            }
        });
        ObjectMapper om = new ObjectMapper();
        try {
            return om.writeValueAsString(map);
        } catch (JsonProcessingException e) {
            throw new RuntimeException();
        }
    }

    private Optional<String> statusFilterExpression(Map<String, Object>
                                                            expressionAttributeValuesBuilder, Optional<OrderState> status) {
        return status.map(s -> {
            expressionAttributeValuesBuilder.put(":orderStatus", s.toString());
            return "orderStatus = :orderStatus";
        });
    }

    private String keywordFilterExpression(Map<String, Object>
                                                   expressionAttributeValuesBuilder, Set<String> kw) {
        Set<String> keywords = tokenize(kw);
        if (keywords.isEmpty()) {
            return "";
        }
        String cuisinesExpression = "";
        int idx = 0;
        for (String cuisine : keywords) {
            String var = ":keyword" + idx;
            String cuisineExpression = String.format("contains(keywords, %s)", var);
            cuisinesExpression = Expressions.or(cuisinesExpression, cuisineExpression);
            expressionAttributeValuesBuilder.put(var, cuisine);
        }

        return cuisinesExpression;
    }

//  @Override
//  public OrderHistory findOrderHistory(String consumerId,
// OrderHistoryFilter filter) {
//    AvMapBuilder expressionAttributeValuesBuilder = new AvMapBuilder
// (":cid", new AttributeValue(consumerId))
//            .add(":oct", new AttributeValue().withN(Long.toString(filter
// .getSince().getMillis())));
//    StringBuilder filterExpression = new StringBuilder();
//    Set<String> keywords = tokenize(filter.getKeywords());
//    if (!keywords.isEmpty()) {
//      if (filterExpression.length() > 0)
//        filterExpression.append(" AND ");
//      filterExpression.append(" ( ");
//      int idx = 0;
//      for (String cuisine : keywords) {
//        if (idx++ > 0) {
//          filterExpression.append(" OR ");
//        }
//        String var = ":keyword" + idx;
//        filterExpression.append("contains(keywords, ").append(var).append
// (')');
//        expressionAttributeValuesBuilder.add(var, cuisine);
//      }
//
//      filterExpression.append(" ) ");
//    }
//    filter.getStatus().ifPresent(status -> {
//      if (filterExpression.length() > 0)
//        filterExpression.append(" AND ");
//      filterExpression.append("orderStatus = :orderStatus");
//      expressionAttributeValuesBuilder.add(":orderStatus", status.toString
// ());
//    });
//    QueryRequest ar = new QueryRequest()
//            .withTableName(FTGO_ORDER_HISTORY_BY_ID)
//            .withIndexName(FTGO_ORDER_HISTORY_BY_CONSUMER_ID_AND_DATE)
//            .withScanIndexForward(false)
//            .withKeyConditionExpression("consumerId = :cid AND
// creationDate > :oct")
//            .withExpressionAttributeValues
// (expressionAttributeValuesBuilder.map());
//    System.out.print("filterExpression.toString()=" + filterExpression
// .toString());
//    if (filterExpression.length() > 0)
//      ar.withFilterExpression(filterExpression.toString());
//
//    QuerySpec spec = new QuerySpec();
//    ItemCollection<QueryOutcome> result = table.query(spec);
//
//    List<Map<String, AttributeValue>> items = client.query(ar).getItems();
//    return new OrderHistory(items.stream().map(this::toOrder).collect
// (toList()));
//  }

    @Override
    public boolean updateOrderState(String orderId, OrderState newState, Optional<SourceEvent> eventSource) {
        UpdateItemSpec spec = new UpdateItemSpec()
                .withPrimaryKey("orderId", orderId)
                .withUpdateExpression("SET #orderStatus = :orderStatus")
                .withNameMap(Collections.singletonMap("#orderStatus",
                        ORDER_STATUS_FIELD))
                .withValueMap(Collections.singletonMap(":orderStatus", newState.toString()))
                .withReturnValues(ReturnValue.NONE);
        return idempotentUpdate(spec, eventSource);
    }


    static PrimaryKey makePrimaryKey(String orderId) {
        return new PrimaryKey().addComponent("orderId", orderId);
    }

    @Override
    public void noteTicketPreparationStarted(String orderId) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void noteTicketPreparationCompleted(String orderId) {
        throw new UnsupportedOperationException();

    }

    @Override
    public void notePickedUp(String orderId, Optional<SourceEvent> eventSource) {
        UpdateItemSpec spec = new UpdateItemSpec()
                .withPrimaryKey("orderId", orderId)
                .withUpdateExpression("SET #deliveryStatus = :deliveryStatus")
                .withNameMap(Collections.singletonMap("#deliveryStatus",
                        DELIVERY_STATUS_FIELD))
                .withValueMap(Collections.singletonMap(":deliveryStatus",
                        DeliveryStatus.PICKED_UP.toString()))
                .withReturnValues(ReturnValue.NONE);
        idempotentUpdate(spec, eventSource);
    }

    @Override
    public void updateLocation(String orderId, Location location) {
        throw new UnsupportedOperationException();

    }

    @Override
    public void noteDelivered(String orderId) {
        throw new UnsupportedOperationException();

    }

    @Override
    public Optional<Order> findOrder(String orderId) {
        Item item = table.getItem(new GetItemSpec()
                .withPrimaryKey(makePrimaryKey(orderId))
                .withConsistentRead(true));
        return Optional.ofNullable(item).map(this::toOrder);
    }


    private Order toOrder(Item avs) {
        Order order = new Order(avs.getString("orderId"),
                avs.getString("consumerId"),
                OrderState.valueOf(avs.getString("orderStatus")),
                toLineItems2(avs.getList("lineItems")),
                null,
                avs.getLong("restaurantId"),
                avs.getString("restaurantName"));
        if (avs.hasAttribute("creationDate"))
            order.setCreationDate(new DateTime(avs.getLong("creationDate")));
        return order;
    }


    private List<OrderLineItem> toLineItems2(List<LinkedHashMap<String,
            Object>> lineItems) {
        return lineItems.stream().map(this::toLineItem2).collect(toList());
    }

    private OrderLineItem toLineItem2(LinkedHashMap<String, Object>
                                              attributeValue) {
        return new OrderLineItem((String) attributeValue.get("menuItemId"),
                (String) attributeValue.get("menuItemName"),
                new Money((String) attributeValue.get("price")),
                ((BigDecimal) attributeValue.get("quantity")).intValue()
        );
    }

}
